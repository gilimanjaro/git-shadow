#!/bin/bash

LOCAL_REPO=$(git rev-parse --show-toplevel)
if [ -z "$LOCAL_REPO" ]; then
#	echo "fatal: Unable to establish the top-level URL for the local repository"
	exit 1
fi 

#TODO: SSH=GIT_SSH||which ssh
SSH=$(which ssh)

FSWATCH=$(which fswatch)
if [ -z "$FSWATCH" ]; then
	echo "fatal: You must have fswatch installed to use git-sync-remote"
	exit 1
fi

LOCAL_BRANCH=$(git rev-parse --abbrev-ref HEAD)
if [ -z "$LOCAL_BRANCH" ]; then
	echo "fatal: Unable to establish the currently checked out branch"
	exit 1
fi

REMOTE=$1
if [ -z "$REMOTE" ]; then
	REMOTE=$(git config branch.$LOCAL_BRANCH.remote)
	if [ -z "$REMOTE" ]; then
		echo "fatal: You did not specify a remote to use and unable to establish default remote for this branch"
		exit 1
	fi
#	echo "Using default remote '$REMOTE' for current branch '$LOCAL_BRANCH'"
fi

REMOTE_URL=$(git config remote.$REMOTE.url)
if [ -z "$REMOTE_URL" ]; then
	echo "fatal: Unable to establish the URL for remote '$REMOTE'"
	exit 1
fi

# Figure out what the remote merge refspec is for the our branch
REMOTE_REF=$(git config branch.$LOCAL_BRANCH.merge | sed -e 's/refs\/heads\///')
# We now have the full refspec as it's known on the remote; may want to strip refs/heads/

# Split out the remote hostname and relative path parts for ssh usage
IFS=: read REMOTE_HOST REMOTE_PATH <<<"$REMOTE_URL"

# Determine which branch is checked out remotely
REMOTE_BRANCH=$($SSH $REMOTE_HOST git --git-dir $REMOTE_PATH/.git rev-parse --abbrev-ref HEAD)

#echo "Remote has checked out branch: $REMOTE_BRANCH"

# Determine if the remote is dirty
REMOTE_DIRTY=$($SSH $REMOTE_HOST git --git-dir $REMOTE_PATH/.git --work-tree $REMOTE_PATH status --porcelain)

if [ -n "$REMOTE_DIRTY" ] && [ $REMOTE_BRANCH != $REMOTE_REF ]; then
	echo "fatal: Remote is on a different branch ($REMOTE_BRANCH) and has local changes; can't continue"
	# Actually, we could just stash the changes on the remote. That's for version 2
	exit 1
fi

# if remote-branch != local-branch checkout correct branch on remote
if [ $REMOTE_BRANCH != $REMOTE_REF ]; then
	echo "Remote is on different branch ($REMOTE_BRANCH); switching to '$REMOTE_REF'"
	$SSH $REMOTE_HOST git --git-dir $REMOTE_PATH/.git --work-dir $REMOTE_PATH checkout $REMOTE_REF
	# Do we need to re-check dirty? I don't think so right?
fi

# ** we are now on the same branch **

LOCAL_DIRTY=$(git status --porcelain)

LOCAL_SHA=$(git rev-parse $LOCAL_BRANCH)
REMOTE_SHA=$(git ls-remote -h $REMOTE $REMOTE_REF | cut -f1)

echo "Local SHA is $LOCAL_SHA"
echo "Remote SHA is $REMOTE_SHA"

if [ $LOCAL_SHA != $REMOTE_SHA ]; then
	if git merge-base --is-ancestor $LOCAL_SHA $REMOTE_SHA ; then
		echo "fatal: Local is behind remote; you should fetch, stash and fast-forward your local repo first"
		exit 1
	fi
	if git merge-base --is-ancestor $REMOTE_SHA $LOCAL_SHA ; then
		echo "fatal: Remote is behind of us; we should probably remote-stash, push to, and fast-forward the remote to where we are"
		git push --quiet $REMOTE $LOCAL_BRANCH
		exit 1
	fi
	echo "fatal: Remote is neither descendant nor ancestor; we've diverged. Fix it."
	exit 1
fi

# ** we should now be on the same commit **

if [ -n "$REMOTE_DIRTY" ]; then
	if [ -z "$LOCAL_DIRTY" ]; then
		echo "fatal: Remote has uncommitted changes or untracked files, but local is clean; can't continue";
		# Actually, we could easily stash the remote
		exit 1;
	else
		echo "fatal: Both local and remote have uncommitted changes or untracke files aborting as we could have diverged"
		# we should to a dry-run rsync from remote to local to test for differences with rsync: ABORT IF ANY BECAUSE WE HAVE DIVERGED (or stash-remote, rsync push, stash-apply and retest)
		exit 1
	fi
else
	if [ -n "$LOCAL_DIRTY" ]; then
		echo "Rsyncing our local changes to the remote"
		rsync --dry-run --verbose --archive $LOCAL_REPO $REMOTE_URL
	fi
fi

# ** we are now in sync, both for git and for filesystem

echo "We can now monitor $LOCAL_REPO for changes and sync them to $REMOTE_URL"


